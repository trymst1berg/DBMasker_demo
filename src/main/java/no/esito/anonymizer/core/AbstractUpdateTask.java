/*
 * Copyright 2018-2021 Esito AS
 * Licensed under the g9 Anonymizer Runtime License Agreement (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *      http://download.esito.no/licenses/anonymizerruntimelicense.html
 */
package no.esito.anonymizer.core;

import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashSet;
import java.util.List;

import no.esito.anonymizer.IAnonymization;
import no.esito.anonymizer.IColumn;
import no.esito.anonymizer.IContext;
import no.esito.anonymizer.IContext.RunType;
import no.esito.anonymizer.IDataSource;
import no.esito.anonymizer.IUpdateColumns;

public abstract class AbstractUpdateTask extends AbstractWorkTask implements IUpdateColumns {

    ArrayList<ArrayKey> keysbefore;

    String[][] keyswhere;

    @Override
    public void run(IContext context) throws Throwable {
        start(context, prefix);
        updateTask(context);
        finish(context, prefix);
    }

    private void updateTask(IContext context) throws Throwable {
        IDataSource ds = context.getDatasource();
        IAnonymization[] anonymizations = getAnonymizations();
        if (anonymizations.length == 0) {
            return;
        }
        IColumn[] columns = getColumns();
        List<String> colnames = IColumn.listNames(columns);
        prepareInputs(context, anonymizations);
        List<String[]> rows = context.getDatasource().dsReadRows(getTable(), colnames, getWhere());
        if (rows.isEmpty()) {
            return;
        }
        IColumn[] index = getIndexColumns();
        IAnonymization[] keys = getKeyAno(anonymizations, index);
        if (keys != null) {
            // We are updating the primary key and needs to remember the original values
            int[] keycolumnnums = new int[index.length];
            for (int j = 0; j < index.length; j++) {
                keycolumnnums[j] = colnames.indexOf(index[j].getName());
            }
            keysbefore = new ArrayList<>(rows.size());
            for (String[] row : rows) {
                String[] keyvalues = new String[index.length];
                for (int j = 0; j < index.length; j++) {
                    keyvalues[j] = row[keycolumnnums[j]];
                }
                keysbefore.add(new ArrayKey(keyvalues));
            }
        }
        keyswhere = new String[index.length][];
        for (int i = 0; i < index.length; i++) {
            IColumn col = index[i];
            int colnum = colnames.indexOf(col.getName());
            String[] wc = new String[rows.size()];
            keyswhere[i] = wc;
            for (int j = 0; j < rows.size(); j++) {
                wc[j] = rows.get(j)[colnum];
            }
        }
        Collection<String> updatecolumns = new LinkedHashSet<>();
        for (IAnonymization anonymization : anonymizations) {
            updatecolumns.add(anonymization.getColumn().getName());
            anonymization.run(context, colnames, rows);
        }
        if (keys != null) {
            // case of autogenerated keys
            if (keys.length == 1 && keys[0] instanceof AbstractMasking && ((AbstractMasking) keys[0]).getInputs().length == 0) {
                ds.dsUpdateRowsWithKeyAuto(getTable(), getColumns(),colnames, updatecolumns, rows, keys[0],keysbefore);
            } else {
                ds.dsUpdateRowsWithKey(getTable(), getColumns(), getIndexColumns(), colnames, updatecolumns, rows, keys,keysbefore,keyswhere);
            }
        } else {
            if (keyswhere.length == 0) {
                ds.dsUpdateRowsNoIndex(getTable(),columns, new ArrayList<>(updatecolumns), rows);
            } else {
                ds.dsUpdateRows(getTable(),columns, index, new ArrayList<>(updatecolumns), rows, keyswhere);
            }
        }
    }

    @Override
    public boolean shouldRun(IContext context) {
        return context.getRunType() == RunType.RUN;
    }

    public static IAnonymization[] getKeyAno(IAnonymization[] anonymizations, IColumn[] indexcolumns) {
        List<IAnonymization> keys = new ArrayList<>();
        for (IColumn column : indexcolumns) {
            IAnonymization anonymization = getAno(anonymizations, column);
            if (anonymization != null) {
                keys.add(anonymization);
            }
        }
        return keys.isEmpty() ? null : keys.toArray(new IAnonymization[keys.size()]);
    }

    public static IAnonymization getAno(IAnonymization[] anonymizations, IColumn column) {
        for (IAnonymization anonymization : anonymizations) {
                if (column.getName().equals(anonymization.getColumn().getName())) {
                    return anonymization;
            }
        }
        return null;
    }

    @Override
    protected void initCols(Collection<IColumn> cols) {
        for (IColumn col : getIndexColumns()) {
            cols.add(col);
        }
        registerAnonymizations(cols, getAnonymizations());
        for (IColumn col : getAllColumns()) {
            cols.add(col);
        }
    }

}
